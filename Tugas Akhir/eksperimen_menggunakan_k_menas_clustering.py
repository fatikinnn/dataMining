# -*- coding: utf-8 -*-
"""Eksperimen Menggunakan K-Menas Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ydlKwGPMsbhytlmmzYNaUHpW4K1iZxYg
"""

# Impor library yang diperlukan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score

# Load Datasets
file_path = "OnlineRetail.csv"

# Memuat dataset dari file CSV menggunakan library pandas
df = pd.read_csv(file_path, encoding="unicode_escape")

# Eksplorasi Data
print(df.head())  # Melihat beberapa baris pertama dataset
print(df.info())  # Informasi tentang tipe data dan nilai-nilai yang hilang

# Pembersihan Data
df.drop_duplicates(inplace=True)  # Menghapus data duplikat
df.dropna(inplace=True)  # Menghapus baris yang mengandung nilai-nilai yang hilang

# Preprocessing Data
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])  # Mengonversi InvoiceDate ke tipe datetime

# Karena K-means sensitif terhadap skala data, kita perlu melakukan standarisasi
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data[['Quantity', 'UnitPrice']])

# Analisis Pola Pembelian
# Mencari tren belanja berdasarkan waktu
df['YearMonth'] = df['InvoiceDate'].dt.to_period('M')
shopping_trends = df.groupby('YearMonth')['Quantity'].sum()

# Konversi YearMonth dari Period ke tanggal (tanggal awal setiap bulan)
shopping_trends.index = shopping_trends.index.to_timestamp()

# Visualisasi tren belanja berdasarkan waktu
plt.figure(figsize=(10, 6))
plt.plot(shopping_trends.index, shopping_trends, marker='o', linestyle='-')
plt.xlabel('Bulan')
plt.ylabel('Jumlah Barang Terbeli')
plt.title('Tren Belanja Pelanggan Berdasarkan Waktu')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

# Segmentasi Pelanggan dengan K-means Clustering
# Menentukan jumlah kluster yang optimal dengan menggunakan Elbow Method
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=42)
    kmeans.fit(data_scaled)
    wcss.append(kmeans.inertia_)

# Plot Elbow Method untuk menentukan jumlah kluster yang optimal
plt.figure(figsize=(8, 6))
plt.plot(range(1, 11), wcss, marker='o')
plt.xlabel('Jumlah Kluster')
plt.ylabel('Within-Cluster Sum of Squares (WCSS)')
plt.title('Elbow Method untuk Menentukan Jumlah Kluster Optimal')
plt.grid(True)
plt.show()

# Berdasarkan plot Elbow Method, pilih jumlah kluster yang optimal dan lakukan clustering
n_clusters = 4
kmeans = KMeans(n_clusters=n_clusters, init='k-means++', max_iter=300, n_init=10, random_state=42)
data['Cluster'] = kmeans.fit_predict(data_scaled)

# Evaluasi hasil clustering
silhouette_avg = silhouette_score(data_scaled, data['Cluster'])
print(f"Silhouette Score untuk jumlah kluster {n_clusters}: {silhouette_avg}")

# Visualisasi hasil clustering
plt.figure(figsize=(10, 6))
for i in range(n_clusters):
    cluster_data = data[data['Cluster'] == i]
    plt.scatter(cluster_data['Quantity'], cluster_data['UnitPrice'], label=f'Cluster {i+1}')
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=200, c='red', marker='*', label='Centroids')
plt.xlabel('Quantity (Standarized)')
plt.ylabel('UnitPrice (Standarized)')
plt.title('Hasil Clustering dengan K-means')
plt.legend()
plt.grid(True)
plt.show()